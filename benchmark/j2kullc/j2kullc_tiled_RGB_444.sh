#    Opentestbench : an open-source framework to assess the performances of image compression schemes
#    Copyright (C) 2015  intoPIX s.a. , Sébastien Lugan 
#    Copyright (C) 2015  Universite Catholique de Louvain, Alexandre Willème
#
#    Opentestbench is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#    
#   For any question please contact : 
#   Alexandre Willème (alexandre.willeme@uclouvain.be)

#!/bin/bash
export LANG=C

source benchmark/paths.sh

function xstr
{
  echo $(for ((i=0;i<${1};++i)); do echo -n ${2}; done)
}

function kdu_compress
{
  geom=${1}
  kinput_file_r=${2}
  kinput_file_g=${3}
  kinput_file_b=${4}
  koutput_file=${5}
  rate=${6}
	bit_depth=${7}
  levels=${8}
  if [ -z ${levels} ]; then
    levels=5
  fi
  Cblk=${9}
  if [ -z ${Cblk} ]; then
    Cblk=32x32
  fi
  Cblk=${Cblk##*x},${Cblk/x*}
  Cprec=$(xstr $((${levels})) "{256,256},")"{128,128}"
  
  local width=${geom/x*}
  local height=${geom#*x}

  LD_LIBRARY_PATH=${KDUPATH} ${KDUPATH}/kdu_compress \
  -i  ${kinput_file_r},${kinput_file_g},${kinput_file_b} -o ${koutput_file} \
  Stiles="{2,8192}" ORGgen_tlm=3 ORGtparts=C Corder="{CPRL}" Clevels=${levels} \
	Mprecision=${bit_depth},${bit_depth},${bit_depth} Sprecision=${bit_depth},${bit_depth},${bit_depth} Ssigned=no,no,no \
	Sdims="{${height},${width}},{${height},${width}},{${height},${width}}" \
  Scomponents=3 Cprecincts="${Cprec}" Cblk="{${Cblk}}" Creversible=no Cycc=yes Cmodes="{RESET|RESTART|CAUSAL|BYPASS}" -precise Qstep=.0001 \
  -rate ${rate} -no_weights -num_threads 0 -fprec ${bit_depth},${bit_depth},${bit_depth}
}

function kdu_expand
{
  LD_LIBRARY_PATH=${KDUPATH} ${KDUPATH}/kdu_expand -i ${1} -o ${2} -precise -fprec ${3} -num_threads 0
}

function tiled_compress
{	
	bpp=$1
	src_file=$2
	image_size=$3
	bit_depth=$4
	stripes_height=$5
	test_file=$6
  errorPos=${7}
  numBits=${8}

	if [ ${errorPos} = 0 ] && [ ${numBits} = 0 ]; then
			errorTest=0
	else
			errorTest=1
	fi


  sn=${src_file##*/}  	# Short name
  bn=${sn/.*}           # Base name
	
  width=${image_size/x*}
  height=${image_size#*x}
	
  # Stripes geometry
  res_full=${width}x${height}
  res_R=${width}x${stripes_height}
  res_G=${width}x${stripes_height}
  res_B=${width}x${stripes_height}
	tilenum=$(bc <<< "${height}/${stripes_height}")
  tile=1x${tilenum}

  # J2K parameters
  cblk=1024x4
  levels=6

  # Step 1: split the image

  if [ ! -d ${TMPDIR}/t_${res_R} ]; then
    mkdir ${TMPDIR}/t_${res_R}
  fi
	
	if [ $bit_depth = "8" ]; then
			format_specifier_R="@${width}x${height}x3:[8=0]"
			format_specifier_G="@${width}x${height}x3:[8=1]"
			format_specifier_B="@${width}x${height}x3:[8=2]"
			imdepth_specifier="-depth 8"
	elif [ $bit_depth = "10" ]; then
			format_specifier_R="@${width}x${height}x3:[6-],[10-=0]"
			format_specifier_G="@${width}x${height}x3:[6-],[10-=1]"
			format_specifier_B="@${width}x${height}x3:[6-],[10-=2]"
			imdepth=""
	elif [ $bit_depth = "12" ]; then
			format_specifier_R="@${width}x${height}x3:[4-],[12-=0]"
			format_specifier_G="@${width}x${height}x3:[4-],[12-=1]"
			format_specifier_B="@${width}x${height}x3:[4-],[12-=2]"
			imdepth=""
	fi
	${DIFFTESTPATH}/difftest_ng --convert ${TMPDIR}/t_${res_R}/component_r.raw${format_specifier_R} ${src_file} -
	${DIFFTESTPATH}/difftest_ng --convert ${TMPDIR}/t_${res_G}/component_g.raw${format_specifier_G} ${src_file} -
	${DIFFTESTPATH}/difftest_ng --convert ${TMPDIR}/t_${res_B}/component_b.raw${format_specifier_B} ${src_file} -

  input_cmp=(${TMPDIR}/t_${res_R}/component_{r,g,b}.raw)
  ${IMPATH}/convert ${imdepth_specifier} -size ${res_full} g:${input_cmp[0]} -crop ${res_R} \
          -endian msb g:${TMPDIR}/t_${res_R}/${bn}_r_%03d.raw
  ${IMPATH}/convert ${imdepth_specifier} -size ${res_full} g:${input_cmp[1]} -crop ${res_G} \
          -endian msb g:${TMPDIR}/t_${res_G}/${bn}_g_%03d.raw
  ${IMPATH}/convert ${imdepth_specifier} -size ${res_full} g:${input_cmp[2]} -crop ${res_B} \
          -endian msb g:${TMPDIR}/t_${res_B}/${bn}_b_%03d.raw

  # Step 2: compress the individual tiles
  dirname=${TMPDIR}/r_${bpp}_${cblk}_${res_R}
  if [ ! -d ${dirname} ]; then mkdir ${dirname}; fi

	numbStripes=$(find ${TMPDIR}/t_${res_R} -type f -name ${bn}'_r_*.raw' | wc -l)
	echo numbStripes ${numbStripes} tilenum ${tilenum}

	#if the image height is not multiple of the stripe_height
	if [ ${numbStripes} != ${tilenum} ]; then
		propFloat=$(bc <<< "scale=4; ${height}/${stripes_height}")
		propRound=$(bc <<< "${height}/${stripes_height}")
		pcToCrop=$(bc <<< "scale=4; ${propFloat}-${propRound}")
		linesToCrop=$(bc <<< "((${pcToCrop}*${stripes_height})+0.5)/1")
		echo ${propFloat} ${propRound} ${pcToCrop} ${linesToCrop}
		${DIFFTESTPATH}/difftest_ng --crop 1 $(bc <<< "(${height}-${linesToCrop})") $(bc <<< "(${width})") $(bc <<< "(${height})") --convert ${TMPDIR}/t_${res_R}/${bn}_r_${tilenum}.raw${format_specifier_R/${height}/${linesToCrop}} ${input_cmp[0]}${format_specifier_R} -
		${DIFFTESTPATH}/difftest_ng --crop 1 $(bc <<< "(${height}-${linesToCrop})") $(bc <<< "(${width})") $(bc <<< "(${height})") --convert ${TMPDIR}/t_${res_G}/${bn}_r_${tilenum}.raw${format_specifier_G/${height}/${linesToCrop}} ${input_cmp[1]}${format_specifier_G} -
		${DIFFTESTPATH}/difftest_ng --crop 1 $(bc <<< "(${height}-${linesToCrop})") $(bc <<< "(${width})") $(bc <<< "(${height})") --convert ${TMPDIR}/t_${res_B}/${bn}_r_${tilenum}.raw${format_specifier_B/${height}/${linesToCrop}} ${input_cmp[2]}${format_specifier_B} -
		echo cool
	fi
	
	i=0
  for f in "${TMPDIR}/t_${res_R}/${bn}_r"_*.raw; do
    out=${dirname}/kdu_${f##*/}
    out=${out/_r_/_}
    out=${out/.raw}.j2k
		#for the last image which is smaller
		if [ $i == ${tilenum} ]; then
			kdu_compress ${width}x${linesToCrop} ${f} ${f/_r_/_g_} ${f/_r_/_b_} ${out} ${bpp} ${bit_depth} ${levels} ${cblk} #2>&1 > /dev/null
		else
    	kdu_compress ${res_R} ${f} ${f/_r_/_g_} ${f/_r_/_b_} ${out} ${bpp} ${bit_depth} ${levels} ${cblk} #2>&1 > /dev/null
		fi
    wait
		i=$(bc <<< "${i}+1")
  done
	#display ok

# Step 3: uncompress the individual tiles
  let i=0
  posError=$(bc <<< "scale=4; $errorPos*($tilenum)")
  for f in "${dirname}/kdu_${bn}"_*.j2k; do
		if [ ${errorTest} = 1 ]; then
			let lowBound=i
		  let highBound=i+1
	    #echo OOK $lowBound $highBound OK
	    #echo $posError
		  flagIn=$(bc <<< "scale=4; $posError>$lowBound && $posError<$highBound")
	    #echo $flagIn
		  if [ $flagIn = 1 ]; then
	        #echo temper $f
		      insidePos=$(bc <<< "scale=4; ($posError-$lowBound)") 
		      ${EIPATH}/error_insertion1b "${f}" ${insidePos} ${numBits}
		  fi
		fi
    kdu_expand "${f}" "${f/.j2k}_rgb.ppm" ${bit_depth} #2>&1 > /dev/null
    wait
		let i=i+1
  done
 # Step 4: recombine the individual tiles
${IMPATH}/montage -tile 1x${tilenum} -geometry ${res_R} -size ${res_R} -depth ${bit_depth} -endian msb \
    ${dirname}/kdu_${bn}_???_rgb.ppm ${TMPDIR}/almostcomplete.ppm
#concatenate the big picture with the small part if needed
if [ ${numbStripes} != ${tilenum} ]; then
	display ok
	if [ $bit_depth = "8" ]; then
			end_format_specifier=":{8=0}:{8=1}:{8=2}:"
	elif [ $bit_depth = "10" ]; then
			end_format_specifier=":{6-},{10-=0}:{6-},{10-=1}:{6-},{10-=2}:"
	elif [ $bit_depth = "12" ]; then
			end_format_specifier=":{4-},{12-=0}:{4-},{12-=1}:{4-},{12-=2}:"
	fi
	${DIFFTESTPATH}/difftest_ng --convert ${TMPDIR}/almostcompleteinterleaved.raw@${width}x$(bc <<< "${height}-${linesToCrop}")x3${end_format_specifier} ${TMPDIR}/almostcomplete.ppm -
	${DIFFTESTPATH}/difftest_ng --convert ${TMPDIR}/smallpartinterleaved.raw@${width}x${linesToCrop}x3${end_format_specifier} ${dirname}/kdu_${bn}_*${tilenum}_rgb.ppm -
	cat ${TMPDIR}/almostcompleteinterleaved.raw ${TMPDIR}/smallpartinterleaved.raw >> ${TMPDIR}/okinterleaved.raw
	${DIFFTESTPATH}/difftest_ng --convert ${test_file} ${TMPDIR}/okinterleaved.raw@${width}x${height}x3${end_format_specifier} -
else
	mv ${TMPDIR}/almostcomplete.ppm ${test_file}
fi
}


# usage:
#   j2kullc_tiled_RGB_444_8b.sh bpp src_file image_size bit_depth stripes_height test_file (errorPos) (numBits)

bpp=$1
src_file=$2
image_size=$3
bit_depth=$4
stripes_height=$5
test_file=$6
errorPos=$7
numBits=$8
shift 8

if [ -z ${bpp} ] || [ -z ${src_file} ] || [ -z ${bit_depth} ] || [ -z ${image_size} ] || [ -z ${stripes_height} ] || [ -z ${test_file} ]; then
  echo "Usage: j2kullc_tiled_RGB_444_8b.sh bpp src_file image_size bit_depth stripes_height test_file (errorPos) (numBits)"
  exit 1
fi

if [ -z ${errorPos} ] || [ -z ${numBits} ]; then
	errorPos=0
	numBits=0
fi

TMPDIR=$(mktemp -d /tmp/j2ktilerPPPP_XXXX)
tiled_compress ${bpp} ${src_file} ${image_size} ${bit_depth} ${stripes_height} ${test_file} ${errorPos} ${numBits}
rm -rf ${TMPDIR}
