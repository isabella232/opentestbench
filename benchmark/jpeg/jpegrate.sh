#!/bin/bash
# This script compresses a .ppm or .yuv file to a given rate
# with jpeg or with jpeg ls.
#
# Usage:
# jpegrate -b <rate in bits per pixel> [-ls mode] input.ppm output.jpg
# where "-ls" defines the JPEG-LS mode, 0=scan interleaved, 1=line interleaved
# 2=pixel interleaved (not for yuv-images).
#
# If the input file is in yuv, the file name must be as follows:
# filename_widthxheightxdepthxbits_per_pixel.yuv
#

source benchmark/paths.sh

# Configuration options:
#
# Where is the jpeg executable?
jpeg=${JPEGXTPATH}/jpeg
#
# Where is the difftest utility?
difftest=${DIFFTESTPATH}/difftest_ng
#
# Additional options to jpeg (besides subsampling)
jpegopts=""
#
# A temporary directory to work with
tmpdir="/tmp"
#
# Where does logging go?
logfile="/tmp/jpegrate.log"
echo -n "" >  ${logfile}
#
#-------------------------------------------------------------------------------------
#
# Guess the format of a yuv file from its file name.
# Returns the width in $width, the height in $height, the
# number of components in $depth, the number of bits per
# sample in $bpp.
guessformat()
{
    local infile=$1
    local parms=`echo "$infile" | sed -e 's/.*_\([0-9]*\)x\([0-9]*\)x\([0-9]*\)x\([0-9]*\)\.[a-z]*/\1 \2 \3 \4/'`
    
    width=`echo $parms | cut -f 1 -d ' '`
    height=`echo $parms | cut -f 2 -d ' '`
    depth=`echo $parms | cut -f 3 -d ' '`
    bpp=`echo $parms | cut -f 4 -d ' '`

    if [ "$width" = "" -o "$height" = "" -o "$depth" = "" -o "$bpp" = "" ]; then
	echo "Could not determine the dimensions of the input image $infile"
	exit 25
    fi
}
#
# Convert a yuv file, plane interleaved, to a ppm file.
yuvtoppm()
{
    local infile=$1
    local outfile=$2
    local bpp
    local width
    local height
    local depth

    rm -rf $outfile
    if [ ! -f "$infile" ]; then
	echo "Cannot convert $infile to ppm, it does not exist"
	exit 25
    fi

    guessformat $infile

    cp $infile ${tmpdir}/in.raw

    echo "${difftest} --cup 2 1 --convert $outfile ${tmpdir}/in.raw@${width}x${height}x${depth}:[${bpp}=0]:[${bpp}=1]/2x1:[${bpp}=2]/2x1 -" >>$logfile
    
    ${difftest} --cup 2 1 --convert $outfile ${tmpdir}/in.raw@${width}x${height}x${depth}:[${bpp}=0]:[${bpp}=1]/2x1:[${bpp}=2]/2x1 - 2>&1 >>$logfile

    if [ ! -f "$outfile" ]; then
	echo "unable to convert $infile to $outfile, check $logfile for details"
	exit 25
    fi
}
#
# Return the file name annex in $annex
getannex()
{
    local infile=$1
    annex=`echo $infile | sed -e 's/.*\.//'`
}
#
# Convert the bitrate to a byte size of the output file.
# Return the byte rate in $rate
getbyterate()
{
    local infile=$1
    local bitrate=${2}
    local annex
    local width
    local height
    local depth
    local bpp

    getannex $infile
    if [ "$annex" = "ppm" ]; then
	width=`$difftest --brief --width $infile -`
	height=`$difftest --brief --height $infile -`
    else
	guessformat $infile
    fi
    rate=`echo -e "scale=0\n${bitrate}*${width}*${height}/8" | bc`
}
#
# Measure the size of the given file in bytes, return in $size
measuresize()
{
    local infile=$1
    local dir
    local file

    if [ ! -f "$infile" ]; then
	echo "Compression of ${infile} to ${outfile} failed, see $logfile for details"
	exit 25
    fi

    file=`basename $infile`
    dir=`dirname $infile`
    size=`find ${dir} -name "${file}" -printf "%s\n"`
}
#
# Compress an image with jpeg to a given bytesize. The image must come as ppm
# Arguments are the input file, the output file and the byte rate.
# All remaining arguments are jpeg compressor options.
compressjpegtorate()
{
    local infile=$1
    local outfile=$2
    local targetsize=${3}
    local besttargetsize
    local lastvalid
    local size
    shift 3
    local opts=$*
    local cur=1
    local last=0
    local min=0
    local max=100
    local up=100

    if [ ! -f "${infile}" ]; then
	echo "$infile does not exist, cannot compress"
	exit 25
    fi
    
    # Run a simple rate allocation by bisection
    echo "running a rate allocation now" >>$logfile
    while [ "$cur" != "$last" ]; do
			last=$cur
			cur=`echo "scale=0;($min+$max)/2" | bc`
			rm -rf ${outfile}
			echo "${jpeg} -q ${cur} ${opts} ${infile} ${outfile}" >>$logfile
			${jpeg} -q ${cur} ${opts} ${infile} ${outfile} 2>&1 >>$logfile
			measuresize ${outfile}
			# bisection: Is it too large or too small?
			if [ `echo "$size > $targetsize" | bc` == "1" ]; then
					# rate is too large, lower the quality.
					echo current param $cur  rate is too large, lower the quality. actual size : $size target size : $targetsize
					max=$cur
			else
					echo current param $cur rate is too small, increase the quality. actual size : $size target size : $targetsize
					min=$cur
					lastvalid=$cur
					besttargetsize=$size
			fi
    done
    
    # Increase now the quality for 10 steps of one to see whether we can get any closer.
    # The problem is that the rate need not to be monotoneous in the quality. Yuck!
    cur=$((lastvalid-2>0?lastvalid-2:0))
    last=$((lastvalid+2<up?lastvalid+2:up))
    while [ "$cur" != "$last" ]; do
			rm -rf ${outfile}
			echo "${jpeg} -q ${cur} ${opts} ${infile} ${outfile}" >>$logfile
			${jpeg} -q ${cur} ${opts} ${infile} ${outfile} 2>&1 >>$logfile
			echo The current tested parameter is ${cur}
			measuresize ${outfile}
			if [ `echo "$size <= $targetsize && $size >= $besttargetsize" | bc` == "1" ]; then	
					lastvalid=$cur
					echo The current best parameter is ${lastvalid} with actual size : ${size} target size : $targetsize
			fi
			cur=$((cur+1))
    done

    # Finally, compress with $lastvalid as quality setting
    rm -rf ${outfile}
    echo "${jpeg} -q ${lastvalid} ${opts} ${infile} ${outfile}" >>$logfile
    ${jpeg} -q ${lastvalid} ${opts} ${infile} ${outfile} 2>&1 >>$logfile
    if [ ! -f "${outfile}" ]; then
	echo "Compression of ${infile} to ${outfile} failed, see $logfile for details"
	exit 25
    fi
}
#
#
#
# Compress an image with jpeg ls to a given bytesize. The image must come as ppm
# Arguments are the input file, the output file and the byte rate.
# All remaining arguments are jpeg compressor options.
compresslstorate()
{
    local infile=$1
    local outfile=$2
    local targetsize=${3}
    local besttargetsize
    local lastvalid
    local size
    shift 3
    local opts=$*
    local cur=1
    local last=0
    local min=0
    local max=255
    local up=255

    if [ ! -f "${infile}" ]; then
	echo "$infile does not exist, cannot compress"
	exit 25
    fi
    
    # Run a simple rate allocation by bisection
    echo "running a rate allocation now" >>$logfile
    while [ "$cur" != "$last" ]; do
	last=$cur
	cur=`echo "scale=0;($min+$max)/2" | bc`
	rm -rf ${outfile}
	echo "${jpeg} -m ${cur} ${opts} ${infile} ${outfile}" 2>&1 >>$logfile
	${jpeg} -m ${cur} ${opts} ${infile} ${outfile} 2>&1 >>$logfile
	measuresize ${outfile}
	# bisection: Is it too large or too small?
	if [ `echo "$size > $targetsize" | bc` == "1" ]; then
	    # rate is too large, lower the quality.
			#echo current param $cur  rate is too large, lower the quality. actual size : $size target size : $targetsize
	    min=$cur
	else
			#echo current param $cur rate is too small, increase the quality. actual size : $size target size : $targetsize
	    max=$cur
	    lastvalid=$cur
	    besttargetsize=$size
	fi
    done
    
    # Increase now the quality for 10 steps of one to see whether we can get any closer.
    # The problem is that the rate need not to be monotoneous in the quality. Yuck!
    cur=$((lastvalid-2>0?lastvalid-2:0))
    last=$((lastvalid+2<up?lastvalid+2:up))
    while [ "$cur" != "$last" ]; do
			rm -rf ${outfile}
			echo "${jpeg} -m ${cur} ${opts} ${infile} ${outfile}" >>$logfile
			${jpeg} -m ${cur} ${opts} ${infile} ${outfile} 2>&1 >>$logfile
			#echo The current tested parameter is ${cur}
			measuresize ${outfile}
			if [ `echo "$size <= $targetsize && $size >= $besttargetsize" | bc` == "1" ]; then
					lastvalid=$cur
					#echo The current best parameter is ${lastvalid} with actual size : ${size} target size : $targetsize
			fi
			cur=$((cur+1))
    done

    # Finally, compress with $lastvalid as quality setting
    rm -rf ${outfile}
    echo "${jpeg} -m ${lastvalid} ${opts} ${infile} ${outfile}" >>$logfile
    ${jpeg} -m ${lastvalid} ${opts} ${infile} ${outfile} 2>&1 >>$logfile
    if [ ! -f "${outfile}" ]; then
	echo "Compression of ${infile} to ${outfile} failed, see $logfile for details"
	exit 25
    fi
}
#
# ------------------------------------- main starts here -------------------------------
#
rate=""
opts=""
subopts=""
if [ "$1" = "-b" ]; then
    rate=${2}
    shift 2
fi
if [ "$1" = "-ls" ]; then
    opts="-ls ${2}"
    shift 2
fi

infile=$1
outfile=$2
shift 2
getannex $infile
if [ "$annex" = "yuv" ]; then
    subopts="-c -s 1x1,2x1,2x1"
    yuvtoppm $infile $tmpdir/in.ppm
    infile=$tmpdir/in.ppm
else
		subopts="-cls"
fi
getbyterate $infile $rate
if [ "$opts" = "" ]; then
    compressjpegtorate $infile $outfile $rate $opts $subopts $*
else
    compresslstorate $infile $outfile $rate $opts $subopts $*
fi
