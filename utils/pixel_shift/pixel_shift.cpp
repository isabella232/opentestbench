
#include <stdio.h>
#include <stdlib.h>
#include <string>
#include <math.h>
#include <cstring>


int main(int argc, char *argv[]){

printf("\n Start program \n");

char *inputimagepath = argv[1];
char *outputfilepath = argv[2];
char *widthString = argv[3];
char *heightString = argv[4];
char *bitDepthString = argv[5];
char *chromaSubString = argv[6];
char *verticalShiftString = argv[7];
char *horizontalShiftString = argv[8];



printf("Start ati convert \n");

int width = atoi(widthString);
int height = atoi(heightString);
int bitDepth = atoi(bitDepthString);
int bytespc = ((bitDepth-1)/8)+1;
int chromaSub = atoi(chromaSubString);
int verticalShift = atoi(verticalShiftString);
int horizontalShift = atoi(horizontalShiftString);





printf("check param %s %s %d %d %d %d %d %d \n",inputimagepath, outputfilepath, width, height, bitDepth, chromaSub, verticalShift, horizontalShift);


FILE *inputimagefile;
inputimagefile = fopen(inputimagepath, "r+");

if(inputimagefile == NULL){
	printf("error reading %s input image file \n", inputimagepath);
	fclose(inputimagefile);
	return -1;
}


printf("Start size computations \n");

FILE *outputfile;
outputfile = fopen(outputfilepath, "w");

fseek(inputimagefile, 0, SEEK_END); // seek to end of file
int inputimagesize = ftell(inputimagefile); // get current file pointer
fseek(inputimagefile, 0, SEEK_SET ); //begining of the file


float chroma_width_multiplier;
unsigned int color1, color2;
if(chromaSub == 444){
	chroma_width_multiplier = 1;
	color1 = 0;
	color2 = 0;
}
else if(chromaSub == 422){ 
	chroma_width_multiplier = 0.5;
	color1 = 0;
	color2 = 1 << (bitDepth-1);
}
else{
	printf("Chroma sub  %d is not supported\n", chromaSub);
	fclose(inputimagefile);
	fclose(outputfile);
	return -1;
}

printf("Start size checks \n");

int inputParamsize = (width+(2*chroma_width_multiplier*width))*height*bytespc;
if(inputimagesize != inputParamsize){
	printf("The input image has not the size specified by its param actual size %d (width+(2*chroma_width_multiplier*width))*height*bytespc %d \n", inputimagesize, inputParamsize);
	fclose(inputimagefile);
	fclose(outputfile);
	return -1;
}

//printf("Start array malloc \n");

unsigned char *inputimagecontent;
inputimagecontent = (unsigned char *) malloc(sizeof(unsigned char)*inputimagesize);
fread(inputimagecontent, sizeof(unsigned char), inputimagesize, inputimagefile);

int outputimagesize= inputimagesize;

unsigned char *outputimagecontent;
outputimagecontent = (unsigned char *) malloc(sizeof(unsigned char)*outputimagesize);

int i,q;
int verticaloffsetinput=0;
int verticaloffsetoutput=0;
int trueWidth;
unsigned int blackColor;
int trueHorizontalShift;

trueWidth = width;
blackColor = color1;
trueHorizontalShift = horizontalShift;
if(verticalShift < 0){
	verticaloffsetinput = verticaloffsetinput - (verticalShift*trueWidth*bytespc);
}
for(i=0;i<height;i++){
	//printf("verticaloffsetinput %d verticaloffsetoutput %d \n",verticaloffsetinput, verticaloffsetoutput);
	//blanking at the top
	if((verticalShift > 0) && (i < verticalShift)){
		for(q=0; q<trueWidth; q++){
			memcpy(outputimagecontent+verticaloffsetoutput+(q*bytespc), &blackColor, (unsigned int) bytespc);
		}
	}
	//blanking at the bottom
	else if ((verticalShift < 0) && (i >= (height+verticalShift))){
		for(q=0; q<trueWidth; q++){
			memcpy(outputimagecontent+verticaloffsetoutput+(q*bytespc), &blackColor, (unsigned int) bytespc);
		}
	}
	//filling inside (what does not disappear if vertical shift)
	else{
		for(q=0; q<trueHorizontalShift; q++){
			memcpy(outputimagecontent+verticaloffsetoutput+(q*bytespc), &blackColor, (unsigned int) bytespc);
		}
		memcpy(outputimagecontent+verticaloffsetoutput+((trueHorizontalShift>0)?trueHorizontalShift:0)*bytespc, inputimagecontent+verticaloffsetinput+((trueHorizontalShift<0)?(-trueHorizontalShift):0)*bytespc, (unsigned int) (trueWidth*bytespc));
		for(q=(trueWidth+trueHorizontalShift); q<trueWidth; q++){
			memcpy(outputimagecontent+verticaloffsetoutput+(q*bytespc), &blackColor, (unsigned int) bytespc);
		}		
		verticaloffsetinput=verticaloffsetinput+(trueWidth*bytespc);
	}
	verticaloffsetoutput=verticaloffsetoutput+(trueWidth*bytespc);
}
if(verticalShift > 0){
	verticaloffsetinput = verticaloffsetinput + (verticalShift*trueWidth*bytespc);
}

trueWidth = width*chroma_width_multiplier;	
blackColor = color2;
trueHorizontalShift = horizontalShift*chroma_width_multiplier;
int w;
for(w=0;w<2;w++){
	//printf("verticaloffsetinput %d verticaloffsetoutput %d \n",verticaloffsetinput, verticaloffsetoutput);
	if(verticalShift < 0){
		verticaloffsetinput = verticaloffsetinput - (verticalShift*trueWidth*bytespc);
	}
	for(i=0;i<height;i++){
		//blanking at the top
		if((verticalShift > 0) && (i < verticalShift)){
			for(q=0; q<trueWidth; q++){
				memcpy(outputimagecontent+verticaloffsetoutput+(q*bytespc), &blackColor, (unsigned int) bytespc);
			}
		}
		//blanking at the bottom
		else if ((verticalShift < 0) && (i >= (height+verticalShift))){
			for(q=0; q<trueWidth; q++){
				memcpy(outputimagecontent+verticaloffsetoutput+(q*bytespc), &blackColor, (unsigned int) bytespc);
			}
		}
		//filling inside (what does not disappear if vertical shift)
		else{
			for(q=0; q<trueHorizontalShift; q++){
				memcpy(outputimagecontent+verticaloffsetoutput+(q*bytespc), &blackColor, (unsigned int) bytespc);
			}
			memcpy(outputimagecontent+verticaloffsetoutput+((trueHorizontalShift>0)?trueHorizontalShift:0)*bytespc, inputimagecontent+verticaloffsetinput+((trueHorizontalShift<0)?(-trueHorizontalShift):0)*bytespc, (unsigned int) (trueWidth*bytespc));
			for(q=(trueWidth+trueHorizontalShift); q<trueWidth; q++){
				memcpy(outputimagecontent+verticaloffsetoutput+(q*bytespc), &blackColor, (unsigned int) bytespc);
			}		
			verticaloffsetinput=verticaloffsetinput+(trueWidth*bytespc);
		}
		verticaloffsetoutput=verticaloffsetoutput+(trueWidth*bytespc);
	}
	if(verticalShift > 0){
		verticaloffsetinput = verticaloffsetinput + (verticalShift*trueWidth*bytespc);
	}
}

fwrite(outputimagecontent, sizeof(unsigned char), outputimagesize, outputfile);

}
