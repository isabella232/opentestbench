#include <stdio.h>
#include <stdlib.h>
#include <string>
#include <math.h>
#include <cstring>


int main(int argc, char *argv[]){

//printf("\n Start program \n");

char *leftimagepath = argv[1];
char *widthleftString = argv[2];
char *heightleftString = argv[3];
char *rightimagepath = argv[4];
char *widthrightString = argv[5];
char *heightrightString = argv[6];
char *outputfilepath = argv[7];
char *bitDepthString = argv[8];
char *chromaSubString = argv[9];
char *centralWidthString = argv[10];
char *outputwidthString = argv[11];
char *outputheightString = argv[12];

//printf("Start ati convert \n");

int widthleft = atoi(widthleftString);
int widthright = atoi(widthrightString);
int heightleft = atoi(heightleftString);
int heightright = atoi(heightrightString);
int bitDepth = atoi(bitDepthString);
int bytespc = ((bitDepth-1)/8)+1;
int chromaSub = atoi(chromaSubString);
int centralWidth = atoi(centralWidthString);
int outputwidth = atoi(outputwidthString);
int outputheight = atoi(outputheightString);



unsigned int centralColor;

printf("check param %s %s %s %d %d %d %d %d %d %d %d \n",leftimagepath, rightimagepath, outputfilepath, widthleft, heightleft, widthright, heightright, bytespc, chromaSub, outputwidth, outputheight);


FILE *leftimagefile;
leftimagefile = fopen(leftimagepath, "r+");

FILE *rightimagefile;
rightimagefile = fopen(rightimagepath, "r+");

if(leftimagefile == NULL){
	printf("error reading %s left image file \n", leftimagefile);
	fclose(leftimagefile);
	fclose(rightimagefile);
	return -1;
}
if(rightimagefile == NULL){
	printf("error reading %s right image file \n", rightimagefile);
	fclose(leftimagefile);
	fclose(rightimagefile);
	return -1;
}

//printf("Start size computations \n");

FILE *outputfile;
outputfile = fopen(outputfilepath, "w");

fseek(leftimagefile, 0, SEEK_END); // seek to end of file
int leftimagesize = ftell(leftimagefile); // get current file pointer
fseek(leftimagefile, 0, SEEK_SET ); //begining of the file

fseek(rightimagefile, 0, SEEK_END); // seek to end of file
int rightimagesize = ftell(rightimagefile); // get current file pointer
fseek(rightimagefile, 0, SEEK_SET ); //begining of the file

float chroma_width_multiplier;
unsigned int color1, color2;
if(chromaSub == 444){
	chroma_width_multiplier = 1;
	//color1 = 0;
	color1 = 1 << (bitDepth-1);
	//color2 = 0;
	color2 = 1 << (bitDepth-1);
}
else if(chromaSub == 422){ 
	chroma_width_multiplier = 0.5;
	//color1 = 0;
	color1 = 1 << (bitDepth-1);
	//color2 = 1 << (bitDepth-1);
	color2 = 1 << (bitDepth-1);
}
else{
	printf("Chroma sub  %d is not supported\n", chromaSub);
	fclose(leftimagefile);
	fclose(rightimagefile);
	fclose(outputfile);
	return -1;
}

//printf("Start size checks \n");


int leftParamsize = (widthleft+(2*chroma_width_multiplier*widthleft))*heightleft*bytespc;
if(leftimagesize != leftParamsize){
	printf("The left image has not the size specified by its param actual size %d (widthleft+(2*chroma_width_multiplier*widthleft))*heightleft*bytespc %d \n", leftimagesize, leftParamsize);
	fclose(leftimagefile);
	fclose(rightimagefile);
	fclose(outputfile);
	return -1;
}
int rightParamsize = (widthright+(2*chroma_width_multiplier*widthright))*heightright*bytespc;
if(rightimagesize != rightParamsize){
	printf("The right image has not the size specified by its param actual size %d (widthright+(2*chroma_width_multiplier*widthright))*heightright*bytespc %d \n", rightimagesize, rightParamsize);
	fclose(leftimagefile);
	fclose(rightimagefile);
	fclose(outputfile);
	return -1;
}

if(heightleft != heightright){
	printf("The images do not have the same height left %d right %d \n", heightleft, heightright);
	fclose(leftimagefile);
	fclose(rightimagefile);
	fclose(outputfile);
	return -1;
}

if(widthleft != widthright){
	printf("The images do not have the same width left %d right %d \n", widthleft, widthright);
	fclose(leftimagefile);
	fclose(rightimagefile);
	fclose(outputfile);
	return -1;
}


int height=heightleft;

int topAndBottomBlanking = (outputheight-height)/2;
if((outputheight-height)%2 != 0){
	printf("Error : (outputheight-height)%2 != 0  \n");
	fclose(leftimagefile);
	fclose(rightimagefile);
	fclose(outputfile);
	return -1;
}

int leftAndRightBlanking = (outputwidth-2*widthleft-centralWidth)/2;
if(((outputwidth-2*widthleft-centralWidth)%2 != 0) || (outputwidth-2*widthleft-centralWidth < 0)){
	printf("Error : (outputwidth-2*width-centralWidth)%2 != 0  || (outputwidth-2*widthleft-centralWidth < 0) \n");
	fclose(leftimagefile);
	fclose(rightimagefile);
	fclose(outputfile);
	return -1;
}


//printf("Start array malloc \n");

unsigned char *leftimagecontent;
leftimagecontent = (unsigned char *) malloc(sizeof(unsigned char)*leftimagesize);
fread(leftimagecontent, sizeof(unsigned char), leftimagesize, leftimagefile);

unsigned char *rightimagecontent;
rightimagecontent = (unsigned char *) malloc(sizeof(unsigned char)*rightimagesize);
fread(rightimagecontent, sizeof(unsigned char), rightimagesize, rightimagefile);

int outputimagesize=(outputwidth+(2*chroma_width_multiplier*outputwidth))*outputheight*bytespc;
unsigned char *outputimagecontent;
outputimagecontent = (unsigned char *) malloc(sizeof(unsigned char)*outputimagesize);

//printf("Start Y copy \n");

int i,q, j;
int verticaloffsetleft=0;
int verticaloffsetright=0;
int verticaloffsetoutput=0;
int trueWidthLeft, trueWidthRight, trueCentralWidth, trueLeftAndRightBlanking, trueOutputWidth;
for(j=0;j<3;j++){
	for(i=0;i<outputheight;i++){
		if(j<1){
			trueWidthLeft = widthleft;
			trueWidthRight = widthright;
			trueCentralWidth = centralWidth;
			trueLeftAndRightBlanking = leftAndRightBlanking;
			trueOutputWidth = outputwidth;
			centralColor = color1;
		}
		else{
			trueWidthLeft = widthleft*chroma_width_multiplier;
			trueWidthRight = widthright*chroma_width_multiplier;
			trueCentralWidth = centralWidth*chroma_width_multiplier;	
			trueLeftAndRightBlanking = leftAndRightBlanking*chroma_width_multiplier;
			trueOutputWidth = outputwidth*chroma_width_multiplier;
			centralColor = color2;
		}

		//printf("verticaloffsetleft %d verticaloffsetright %d verticaloffsetoutput %d \n",verticaloffsetleft,verticaloffsetright,verticaloffsetoutput);
		if((i<topAndBottomBlanking) || (i>=topAndBottomBlanking+height)){
			//put top and left blanking
			for(q=0; q<trueOutputWidth; q++){
					memcpy(outputimagecontent+verticaloffsetoutput+(q*bytespc), &centralColor, (unsigned int) bytespc);
			}
		}
		else{
			if(leftAndRightBlanking > 0){
				for(q=0; q<trueLeftAndRightBlanking; q++){
					memcpy(outputimagecontent+verticaloffsetoutput+q*bytespc, &centralColor, (unsigned int) bytespc);
				}
			}
			memcpy(outputimagecontent+verticaloffsetoutput+((trueLeftAndRightBlanking)*bytespc), leftimagecontent+verticaloffsetleft, (unsigned int) (trueWidthLeft*bytespc));
			if(trueCentralWidth > 0){
				for(q=0; q<trueCentralWidth; q++){
					memcpy(outputimagecontent+verticaloffsetoutput+((trueLeftAndRightBlanking+trueWidthLeft+q)*bytespc), &centralColor, (unsigned int) bytespc);
				}
			}
			memcpy(outputimagecontent+verticaloffsetoutput+((trueLeftAndRightBlanking+trueWidthLeft+trueCentralWidth)*bytespc), rightimagecontent+verticaloffsetright, (unsigned int) (trueWidthRight*bytespc));
			if(leftAndRightBlanking > 0){
				for(q=0; q<trueLeftAndRightBlanking; q++){
					memcpy(outputimagecontent+verticaloffsetoutput+(trueLeftAndRightBlanking+trueWidthLeft+trueCentralWidth+trueWidthRight+q)*bytespc, &centralColor, (unsigned int) bytespc);
				}
			}
			if(trueLeftAndRightBlanking+trueWidthLeft+trueCentralWidth+trueWidthRight+trueLeftAndRightBlanking != trueOutputWidth){
				printf("Error : trueLeftAndRightBlanking+trueWidthLeft+trueCentralWidth+trueWidthRight+trueLeftAndRightBlanking != trueOutputWidth) \n");
				fclose(leftimagefile);
				fclose(rightimagefile);
				fclose(outputfile);
				return -1;
			}
			verticaloffsetleft=verticaloffsetleft+trueWidthLeft*bytespc;
			verticaloffsetright=verticaloffsetright+trueWidthRight*bytespc;
		}
		verticaloffsetoutput=verticaloffsetoutput+trueOutputWidth*bytespc;
	}
}

//printf("Chroma copy OK \n");

fwrite(outputimagecontent, sizeof(unsigned char), outputimagesize, outputfile);

}
