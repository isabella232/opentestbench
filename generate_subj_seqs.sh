#    Opentestbench : an open-source framework to assess the performances of image compression schemes
#    Copyright (C) 2015  intoPIX s.a. , Sébastien Lugan 
#    Copyright (C) 2017  Universite Catholique de Louvain, Alexandre Willème
#
#    Opentestbench is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#    
#   For any question please contact : 
#   Alexandre Willème (alexandre.willeme@uclouvain.be)


#!/bin/bash
export LANG=C

# either singlegen multigen or errortest
test_type=multigen

#list of codecs to test 
codec=$1
path=$2

decompressed_dir_path=results/multi_generation/${codec}

orig_dirs=(${path}/HintergrundMusik_1920x1080_8b \
${path}/Tools_1524x1200_8b)
pseudo_orig_dirs=(HintergrundMusik Tools)
# list of bitrates to test  (in bpp)
bpps=(6 6)
x0pos_crop=(930 639)
y0pos_crop=(122 722)
x1pos_crop=(1172 875)
y1pos_crop=(372 892)
# either RGB or YCbCr
color_spaces=(RGB RGB)
# either 444 or 422
chroma_subs=(444 444)
# either 8, 10 or 12 bits
bit_depths=(8 8)
# WIDTHxHEIGHT
image_sizes=(1920x1080 1524x1200)


niter=7
central_width=50
output_size=3840x2160
flickering_period=1
decompressed_sides=(left right)


#-----------------------------------------------------------------------------
tmpdir=/tmp/cool
source benchmark/paths.sh
rm -r ${tmpdir}
mkdir -p ${tmpdir}
for ((b=0; b<${#orig_dirs[@]}; ++b)); do
		for ((y=0; y<${#decompressed_sides[@]}; ++y)); do
					#central_width=${central_widths[$b]}
					#output_size=${output_sizes[$b]}
					#flickering_period=${flickering_periods[$b]}
					decompressed_side=${decompressed_sides[$y]}
					output_width=${output_size/x*}
					output_height=${output_size#*x}
					bpp=${bpps[$b]}
					orig_dir=${orig_dirs[$b]}
					short_name=${orig_dir##*/}
					pseudo_name=${pseudo_orig_dirs[$b]}
					decompressed_name=${short_name}_sb1_${codec}_${bpp/./_}bpp_r${niter}	
					decompressed_path=${decompressed_dir_path}/${decompressed_name}
					mkdir -p ${tmpdir}/${decompressed_name}
					echo ${decompressed_path}
					for f in $(find -L ${decompressed_path} -type f|grep -v ".txt$"|sort); do
						g=${f##*/}
						extension=${g/*.}
						name=${g/.${extension}}
						cp ${f} ${tmpdir}/${decompressed_name}/${name}_0.${extension}		
						cp ${f} ${tmpdir}/${decompressed_name}/${name}_1.${extension}
					done
					mkdir -p ${tmpdir}/${short_name}
					for f in $(find -L ${orig_dir} -type f|grep -v ".txt$"|sort); do
						g=${f##*/}
						extension=${g/*.}
						name=${g/.${extension}}
						cp ${f} ${tmpdir}/${short_name}/${name}_0.${extension}		
						cp ${f} ${tmpdir}/${short_name}/${name}_1.${extension}		
					done
					
					echo "Pre-processing step: ${test_type} codec ${codecs[$b]} bitrate ${bpp} decompressed_dirs ${decompressed_dirs[$b]}"
					bash preprocess/preprocess.sh ${test_type} ${codec} ${bpp} ${tmpdir}/${short_name}  ${tmpdir}/${decompressed_name} ${color_spaces[$b]} ${chroma_subs[$b]} ${bit_depths[$b]} ${image_sizes[$b]} ${flickering_period} ${decompressed_side} ${x0pos_crop[$b]} ${x1pos_crop[$b]} ${y0pos_crop[$b]} ${y1pos_crop[$b]} ${central_width} ${output_width} ${output_height} ${niter} ${pseudo_name}

					#testname=${short_name}_sb1_${codec}_${bpp/./_}bpp_r${niter}_preprocess_fp${flickering_period}_${decompressed_side}_crop_x0_${x0pos_crop[$b]}_x1_${x1pos_crop[$b]}_y0_${y0pos_crop[$b]}_y1_${y1pos_crop[$b]}_cw${central_width}	
					testname=${pseudo_name}_${codec}_${bpp/./_}bpp_${decompressed_side}
					still_folder=${PWD}/preprocessed_material/stills/${codec}/${testname}

					seqs_folder=${PWD}/preprocessed_material/seqs/${codec}
					mkdir -p ${seqs_folder}
					if [[ ("${extension}" == "ppm") && ("${bit_depths[$b]}" == "8") ]]; then
							ffmpeg -r 8 -s ${output_width}x${output_height} -f image2 -vcodec ppm -i ${still_folder}/${name}_%01d.${extension} -vframes 2 -vcodec rawvideo -r 8 ${seqs_folder}/${testname}_short.mov
					elif [[ ("${extension}" == "ppm") && ("${bit_depths[$b]}" == "10") ]]; then
							ffmpeg -r 8 -s ${output_width}x${output_height} -f image2 -vcodec ppm -i ${still_folder}/${name}_%01d.${extension} -vframes 2 -vframes 2 -vcodec v410 -r 8 ${seqs_folder}/${testname}_short.mov
					elif [[ ("${extension}" == "yuv") ]]; then
							#in the context of CE5 use, v410				
							#ffmpeg -r 8 -s ${output_width}x${output_height} -f image2 -vcodec rawvideo -pix_fmt yuv422p10le -i ${still_folder}/${name}_%01d.${extension} -vframes 2 -vcodec v210 -r 8 ${seqs_folder}/${testname}_short.mov
							ffmpeg -r 8 -s ${output_width}x${output_height} -f image2 -vcodec ppm -i ${still_folder}/${name}_%01d.ppm -vframes 2 -vcodec v410 -r 8 ${seqs_folder}/${testname}_short.mov
					else
							echo "This format is not supported"
					fi
					ffmpeg -f concat -i <(for i in {1..20}; do printf "file '%s'\n" ${seqs_folder}/${testname}_short.mov; done) -c copy ${seqs_folder}/${testname}.mov
					rm ${seqs_folder}/${testname}_short.mov
					rm -r ${tmpdir}
		done
done
